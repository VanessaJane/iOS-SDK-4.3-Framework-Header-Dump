/**
 * This header is generated by class-dump-z 0.2a.
 * class-dump-z is Copyright (C) 2009 by KennyTM~, licensed under GPLv3.
 *
 * Source: /System/Library/PrivateFrameworks/GameKitServices.framework/GameKitServices
 */

#import "VCCallSession.h"
#import "GameKitServices-Structs.h"
#import "LoopbackSocketTunnelDelegate.h"
#import <Foundation/NSKeyedUnarchiver.h>

@class TCPTunnelClient, VCCallLinkCongestionDetector, NSArray, VCCallInfo, VCCapabilities, GKRingBuffer, NSString, NSObject, LoopbackSocketTunnel;
@protocol VCCallSessionDelegate, VideoConferenceRealTimeChannel, VideoConferenceChannelQualityDelegate;

__attribute__((visibility("hidden")))
@interface VCCallSession : NSKeyedUnarchiver {
@private
	NSObject<VCCallSessionDelegate>* delegate;
	VCCallInfo* localCallInfo;
	VCCallInfo* remoteCallInfo;
	tagHANDLE* rtpHandle;
	tagHANDLE* rtpVideo;
	tagHANDLE* encodeHandle;
	tagHANDLE* decodeHandle;
	int numEncodedBytes;
	int numBufferBytesAvailable;
	BOOL didUseICE;
	tagCONNRESULT connectionResult;
	int state;
	int audioBundle;
	int payload;
	int videoPayload;
	int sampleRate;
	int samplesPerFrame;
	tagHANDLE* hAUIO;
	tagHANDLE* hSIP;
	double lastReceivedAudio;
	BOOL launchedShutdownThread;
	BOOL isAudioRunning;
	BOOL isWaitingForICEResult;
	BOOL didSend200OK;
	float remoteParticipantVolume;
	NSObject<VideoConferenceRealTimeChannel>* rtChannel;
	LoopbackSocketTunnel* tunnel;
	opaque_pthread_mutex_t mutex;
	BOOL useLoopback;
	BOOL receivedSIPInvite;
	char* remoteSDP;
	char* localSDP;
	unsigned long dwRemoteRTPIP;
	int iRemoteRTPPort;
	int iRemoteRTCPPort;
	VCCapabilities* caps;
	tagHANDLE* hMediaQueue;
	tagHANDLE* hAFRC;
	GKRingBuffer* ringBuf;
	unsigned lastReceived;
	char* bundleBuffer;
	int bundledPackets;
	int packetsPerBundle;
	int canUseSpecialAACBundle;
	int preferredAudioCodec;
	int preferredAACELDBitRate;
	int audioTxBitrate;
	BOOL canBundleAudio;
	BOOL useControlByte;
	BOOL useUEP;
	char* featuresListString;
	BOOL matchedFeaturesString[1600];
	BOOL myFeaturesString[1600];
	unsigned char inputMeter;
	int packetsSinceLastRTCPReport;
	BOOL audioIsPaused;
	BOOL videoIsPaused;
	int audioTimeStampDelta;
	NSArray* mutedPeers;
	int bandwidthUpstream;
	int bandwidthDownstream;
	int aacBlockSize;
	BOOL fInitialBandwidthDetection;
	AudioStreamBasicDescription encodedFormat;
	BOOL shouldDoEncoding;
	double lastReceivedPacketTimestamp;
	BOOL isAttemptingRelay;
	int relayState;
	BOOL allowsRelay;
	BOOL requiresWifi;
	BOOL useCompressedConnectionData;
	int natType;
	unsigned lastSentAudioSampleTime;
	dispatch_source_s* pausedAudioHeartBeat;
	TCPTunnelClient* _tcpTunnelClient;
	double packetLossRate;
	double timeLastCheckedNetworkConditions;
	double timeLastKnowGoodNetworkConditions;
	double networkConditionsTimeoutInSeconds;
	NSString* peerCN;
	unsigned roundTripTime;
	float packetLateAndMissingRatio;
	float callerPreEmptiveTimeoutInSecs;
	int sampleLogCount;
	double timeSinceLastReportedNoPackets;
	double noRemotePacketsTimeout;
	BOOL didAttemptSIPInvite;
	NSObject<VideoConferenceChannelQualityDelegate>* qualityDelegate;
	BOOL shouldTimeoutPackets;
	opaque_pthread_mutex_t srtpLock;
	BOOL didPrepareSRTP;
	BOOL useAFRC;
	VCCallLinkCongestionDetector* congestionDetector;
	BOOL shouldSendAudio;
	BOOL isRemoteDevice4x;
}
@property(retain, nonatomic) VCCallInfo* localCallInfo;
@property(retain, nonatomic) VCCallInfo* remoteCallInfo;
@property(assign) tagHANDLE* rtpHandle;
@property(assign) tagCONNRESULT connectionResult;
@property(assign) int state;
@property(assign) BOOL didUseICE;
@property(assign) int audioBundle;
@property(assign) int videoPayload;
@property(assign) int payload;
@property(assign) int sampleRate;
@property(assign) int samplesPerFrame;
@property(retain) NSObject<VCCallSessionDelegate>* delegate;
@property(readonly, assign) BOOL isAudioRunning;
@property(assign) BOOL isWaitingForICEResult;
@property(assign) BOOL receivedSIPInvite;
@property(assign) NSObject<VideoConferenceRealTimeChannel>* rtChannel;
@property(assign) tagHANDLE* encodeHandle;
@property(assign) tagHANDLE* decodeHandle;
@property(assign) int numEncodedBytes;
@property(assign) int numBufferBytesAvailable;
@property(assign) tagHANDLE* hMediaQueue;
@property(assign) tagHANDLE* hAFRC;
@property(retain, nonatomic) GKRingBuffer* ringBuf;
@property(assign) unsigned lastReceived;
@property(readonly, assign) char* bundleBuffer;
@property(assign) int bundledPackets;
@property(assign) int packetsPerBundle;
@property(assign, nonatomic) BOOL canBundleAudio;
@property(assign) int preferredAudioCodec;
@property(assign) BOOL useControlByte;
@property(assign) BOOL useUEP;
@property(assign) char* featuresListString;
@property(assign) unsigned char inputMeter;
@property(assign, nonatomic) BOOL useCompressedConnectionData;
@property(assign) int bandwidthUpstream;
@property(assign) int bandwidthDownstream;
@property(retain, nonatomic) NSArray* mutedPeers;
@property(readonly, assign) int audioTxBitrate;
@property(readonly, assign) BOOL videoIsPaused;
@property(readonly, assign) BOOL audioIsPaused;
@property(assign, nonatomic) BOOL requiresWifi;
@property(assign, nonatomic) int natType;
@property(assign, nonatomic) unsigned lastSentAudioSampleTime;
@property(assign) int audioTimeStampDelta;
@property(retain, nonatomic) NSString* peerCN;
@property(assign, nonatomic) double packetLossRate;
@property(assign, nonatomic) double networkConditionsTimeoutInSeconds;
@property(assign, nonatomic) unsigned roundTripTime;
@property(assign) NSObject<VideoConferenceChannelQualityDelegate>* qualityDelegate;
@property(assign, nonatomic) float packetLateAndMissingRatio;
@property(assign) BOOL shouldTimeoutPackets;
@property(assign, nonatomic) BOOL useAFRC;
@property(assign, nonatomic) BOOL shouldSendAudio;
@property(readonly, assign, nonatomic) double networkQuality;
+(id)keyPathsForValuesAffectingNetworkQuality;
-(id)init;
-(void)updateLastReceivedPacketWithTimestamp:(double)timestamp;
-(void)updateLastReceivedPacket:(BOOL)packet;
-(void)dealloc;
-(int)encodeAudio:(void*)audio numInputBytes:(int)bytes outputBytes:(void*)bytes3 numOutputBytes:(int)bytes4;
-(BOOL)bundleAudio:(void*)audio numInputBytes:(int)bytes;
-(BOOL)startConnectionWithParticipantID:(id)participantID callID:(int)anId usingBlob:(id)blob isCaller:(BOOL)caller capabilities:(id)capabilities doEncoding:(BOOL)encoding error:(id*)error;
-(BOOL)updateRTCPReport;
-(int)rtcpDescriptor;
-(BOOL)disconnect:(id)disconnect didRemoteCancel:(BOOL)cancel;
-(BOOL)createConnectionDataForParticipantID:(id)participantID pCallID:(int*)anId error:(id*)error;
-(BOOL)isCallOngoing;
-(BOOL)setPauseAudio:(BOOL)audio error:(id*)error;
-(BOOL)setPauseVideo:(BOOL)video error:(id*)error;
-(BOOL)stillWantsToRelay;
-(void)processRelayRequestResponseDict:(id)dict didOriginateRequest:(BOOL)request;
-(void)processRelayUpdateDict:(id)dict didOriginateRequest:(BOOL)request;
-(void)processCancelRelayRequest:(id)request didOriginateRequest:(BOOL)request2;
@end

@interface VCCallSession (PrivateMethods)
-(BOOL)startConnectionWithParticipantID:(id)participantID callID:(int)anId usingBlob:(id)blob isCaller:(BOOL)caller capabilities:(id)capabilities doEncoding:(BOOL)encoding useRelay:(BOOL)relay error:(id*)error;
-(void)startPausedHeartbeat;
-(void)stopPausedHeartbeat;
-(BOOL)createConnectionDataForParticipantID:(id)participantID pCallID:(int*)anId error:(id*)error useRelay:(BOOL)relay;
-(void)processSIPMessage:(char*)message msgOut:(char*)anOut optional:(void*)optional confIndex:(int*)index;
-(void)lock;
-(void)unlock;
-(void)resetState;
-(void)inviteeICEResultTimer:(float)timer shouldBailIfRelay:(BOOL)relay;
-(BOOL)createSDP:(int*)sdp audioPayloadCount:(int)count videoPayloadTypes:(int*)types videoPayloadCount:(int)count4 sdp:(char*)sdp5 numSDPBytes:(int*)bytes error:(id*)error;
-(int)handleIncomingWithCallID:(int)callID msgIn:(const char*)anIn msgOut:(char*)anOut optional:(void*)optional confIndex:(int*)index error:(id*)error;
-(BOOL)getForcedPayload:(int*)payload;
-(void)getAllPayloadsForAudio:(int**)audio count:(int*)count;
-(void)getAllPayloadsForVideo:(int**)video count:(int*)count;
-(BOOL)sendSIPInviteWithError:(id*)error;
-(BOOL)createRTPHandles:(id*)handles;
-(BOOL)createMediaQueueHandle:(id*)handle;
-(BOOL)startRTPWithError:(id*)error;
-(BOOL)matchFeatures:(char*)features remoteFeaturesString:(char*)string localFeaturesString:(char*)string3;
-(BOOL)negotiatePayloadWithError:(id*)error;
-(BOOL)chooseVideoPayload:(int*)payload count:(int)count;
-(BOOL)setRTPDestinationWithError:(id*)error;
-(BOOL)setRTPPayloadWithError:(id*)error;
-(BOOL)setupCallerRTPChannelWithError:(id*)error;
-(BOOL)sipConnectWithError:(id*)error;
-(void)stopAudioIOProc:(id)proc;
-(void)stopAudio;
-(BOOL)startAudio:(id*)audio;
-(BOOL)setupAudioEncoder;
-(void)setupAACELDBitrate;
-(BOOL)allocateBundleBuffer;
-(BOOL)startVideo:(BOOL)video error:(id*)error;
-(BOOL)stopVideo:(BOOL)video error:(id*)error;
-(BOOL)startMediaQueue:(id*)queue;
-(BOOL)stopMediaQueue:(id*)queue;
-(BOOL)startAFRC:(id*)afrc;
-(BOOL)stopAFRC:(id*)afrc;
-(BOOL)setupAudioCodec;
-(BOOL)choosePayload:(int*)payload count:(int)count;
-(void)shutdownVoiceChatFromRemoteSIPSignal:(int)remoteSIPSignal;
-(void)sipConnectThreadProc:(id)proc;
-(unsigned)getAudioRTPID;
-(unsigned)getVideoRTPID;
-(void)stopLoopback;
-(void)stopLoopbackProc:(id)proc;
-(void)doSipEndProc:(id)proc;
-(void)doSipEndAction:(int)action callID:(int)anId;
-(void)notifyDelegateSessionStarted;
-(BOOL)doBandwidthDetection:(tagHANDLE*)detection error:(id*)error;
-(void)initiateRelayRequest;
-(id)createInitiateRelayDictionary;
-(id)createRelayUpdateDictionary:(id)dictionary;
@end

@interface VCCallSession (Callbacks)
-(unsigned)connectionResultCallback:(tagCONNRESULT*)callback didReceiveICEPacket:(BOOL)packet didUseRelay:(BOOL)relay;
-(int)sipCallback:(int)callback callID:(int)anId msgIn:(const char*)anIn msgOut:(char*)anOut optional:(void*)optional confIndex:(int*)index;
@end

@interface VCCallSession (Loopback) <LoopbackSocketTunnelDelegate>
-(void)setupLoopback;
-(void)receivedRealTimeData:(id)data fromParticipantID:(id)participantID;
-(BOOL)createTCPTunnelForParticipantID:(id)participantID relayDictionary:(id)dictionary didOriginateRequest:(BOOL)request;
-(void)deleteTCPTunnel;
-(void)loopbackSocketTunnel:(id)tunnel receivedData:(id)data from:(tagIPPORT*)from;
-(id)description;
-(void)resetLoopback;
@end

